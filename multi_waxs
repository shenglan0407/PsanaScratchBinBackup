#!/reg/g/psdm/sw/external/python/2.7.10/x86_64-rhel7-gcc48-opt/bin/python2.7

import sys
import os

import numpy as np
import h5py
import argparse
from scipy.signal import argrelmax
import pylab as plt

from loki.RingData import RadialProfile, InterpSimple
from loki.utils.postproc_helper import smooth, bin_ndarray
import psana

def fit_line(data):
    """
    fit a line to the end points of a 1-D numpy array

    data, 1D numpy array, e.g. a radial profile
    """
    left_mean = data[:10].mean()
    right_mean = data[-10:].mean()
    slope = (right_mean - left_mean) / data.shape[0]
    
    x = np.arange(data.shape[0])
    return slope * x + left_mean

def norm_data(data):
    """
    Normliaze the numpy array 
     
    data, 1-D numpy array
    """
    data_min = data.min()
    data2 = data- data.min()
    return data2/ data2.max()


parser = argparse.ArgumentParser(description='Data grab')
parser.add_argument('-r', '--run', type=int, required=True, help='run number to process')
parser.add_argument('-m', '--maxcount', type=int, default=None, help='max shots to process')
parser.add_argument('-s', '--start', type=int, default=None, help='first event to process')
parser.add_argument('-p', '--plot', type=int, default=0, help='plot images (1 yes, 0 no)')
args = parser.parse_args()
    

# run number passed as string
run = args.run
start = args.start
plot_imgs = args.plot

#~~~~~analysis  parameters BEGIN

img_sh = (1734, 1731)

# point where forward beam intersects detector
cent_fname = '/reg/data/ana14/cxi/cxilp6715/scratch/bin/center.npy'
mask_fname = '/reg/data/ana14/cxi/cxilp6715/scratch/bin/mask_rough.npy'
cent = np.load( cent_fname)
mask = np.load( mask_fname) 

#~~~~~ WAXS parameters

# minimium and maximum radii for calculating radial profile
waxs_rmin = 100 # pixel units
waxs_rmax = 1110
rp = RadialProfile( cent, img_sh, mask=mask  )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# ~~ hit findin' parameters... 

beta = 50 # smoothing factor
window_size = 200 # pixel units

# maxima detection
order = 250 # defines minimum neighborhood for local maxima (in radial pixel units)
# paraemters for peak validation
pk_range = (800, 1045) # radial pixel units, relative to the range of the radial profiles
# e.g. will ensure the detected peak lies on rad_pofile[ pk_range[0] : pk_range[1]] 

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~ interp parameters

# min ring radii
# desired dimension of image, these will be approximate
rbins = 8
phibins = 360

interp_rmin = 100
interp_rmax = 450

rbin_fct = np.floor( (interp_rmax - interp_rmin) / rbins)
# adjust so our edge is a multiple of rbin factor
interp_rmax = int( interp_rmin + np.ceil( (interp_rmax - interp_rmin) / rbin_fct)*rbin_fct )

nphi = int( 2 * np.pi * interp_rmax )
phibin_fct = np.ceil( nphi / float( phibins ) )
nphi = int( np.ceil( 2 * np.pi * interp_rmax/phibin_fct)*phibin_fct) # number of azimuthal samples per bin

rbin_new = (interp_rmax- interp_rmin ) / rbin_fct
phibin_new = nphi / phibin_fct 
binned_pol_img_sh = (rbin_new, phibin_new)
print("polar image dimensions:  %d x %d"%(rbin_new, phibin_new))

Interp = InterpSimple( cent[0], cent[1] , interp_rmax, interp_rmin, nphi, img_sh)  
pmask = Interp.nearest(mask).astype(int).astype(float)
pmask_bn = bin_ndarray( pmask, binned_pol_img_sh)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~ data get parameters
#load the data events for the given run
ds_str = 'exp=cxilp6715:run=%d:smd' % run
ds = psana.MPIDataSource(ds_str)
events = ds.events()

# open the detector obj
cspad = psana.Detector('CxiDs1.0:Cspad.0')

# make some output dir
root = '/reg/d/psdm/cxi/cxilp6715/scratch/analysis'
outdir = os.path.join( root, 'run%d'%run)
if not os.path.exists(outdir):
    os.makedirs(outdir)

# make output file
out_fname = os.path.join( outdir, 'BigAzzData-%d.hdf5'%(run))

#small dat
smldata = ds.small_data(out_fname)
count = 0

for i,evt in enumerate(events):
    if start is not None:
        if i < start:
            print ("skipping event %d/%d"%(i+1, start))
            continue
    
    img = cspad.image(evt)
    if img is None:
        print("img is None")
        continue

#   WAXS FOR HIT FINDING~~~~~~~~~~~~~~
    rad_pro = rp.calculate(img)[waxs_rmin:waxs_rmax]
    
#   before peak fitting we smooth
    #flat_pro = smooth(rad_pro-fit_line(rad_pro), beta=beta, window_size=window_size) 
    smooth_pro =  smooth(rad_pro, beta=beta, window_size=window_size) 
    #norm_pro = norm_data(flat_pro)

#   we can find local maxima in the smoothed normalized radial profiles... 
    mx = argrelmax(smooth_pro, order=order)[0] 

#   make sure there is only one peak!
    if not len(mx) == 1:
        print("found too many maxs")
        continue

#   make sure the peak lies in the desired range.. 
    pk_pos = mx[0]
    if not pk_range[0] < pk_pos < pk_range[1] : 
        print("max peak is outside of range")
        continue

#   make sure the peak value is max in the original profile, 
#   because it was selected using line-subtracted profile
    pk_val = smooth_pro[ pk_pos] 
    if not smooth_pro[pk_range[0]] < pk_val and not smooth_pro[pk_range[1]] < pk_val :
        print("max is not a true max")
        continue  
#   if made it this far it is a hit, or maybe helium only.. 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~Interpolation to polar
    polar_img = Interp.nearest( img) * pmask
    polar_img_bn = bin_ndarray( polar_img, binned_pol_img_sh)* pmask_bn
    
    if plot_imgs:
        plt.figure(1)
        plt.clf()
        plt.plot( rad_pro, 'x') 
        plt.plot( smooth_pro, lw=5)
        plt.plot( mx, smooth_pro[mx], 'o', ms=10 ) 
        plt.draw()
        plt.pause(0.1)

        plt.figure(2)
        plt.clf()
        plt.imshow( polar_img, aspect='auto', 
            interpolation='nearest', cmap='gnuplot', 
            extent= (0, 360, interp_rmax, interp_rmin),
            vmin=0, vmax=100)
        plt.draw()
        plt.pause(0.1)

        plt.figure(3)
        plt.clf()
        plt.imshow( polar_img_bn, aspect='auto', 
            interpolation='nearest', cmap='gnuplot', 
            extent= (0, 360, interp_rmax, interp_rmin),
            vmin=0)
        plt.draw()
        plt.pause(0.1)

    smldata.event(polar_imgs=polar_img_bn)
    smldata.event(radial_profs=rad_pro)
    count += 1
    print("Images processed: %d out of %d events..."%(count,i+1))

    if args.maxcount is not None:
        if count == args.maxcount:
            break
smldata.save()

